# 📁 Stack & Queue Mastery in C++

This repository contains 10 carefully selected and optimized C++ programs that cover key algorithmic problems using **Stack** and **Queue** data structures. These programs are designed for advanced learners aiming to master stack and queue based solutions, perfect for coding interviews and real-world applications.

---

## 📜 Programs List

### 🔥 Stack-Based Problems

---

### ✅ `01_next_greater_element.cpp`  
Find the **next greater element** for each element in an array using a monotonic stack approach.  
💡 *Efficient O(n) solution using stack to track next greater values.*

---

### ✅ `02_largest_rectangle_histogram.cpp`  
Calculate the **largest rectangle area** in a histogram using stack.  
🧱 *Classic problem demonstrating how to use stacks for area calculation.*

---

### ✅ `03_celebrity_problem.cpp`  
Identify the **celebrity** in a party using stack operations.  
🎉 *Determines if a person is known by everyone but knows no one.*

---

### ✅ `04_remove_k_digits.cpp`  
Given a number as a string, remove **K digits** to obtain the smallest possible number using a greedy stack approach.  
🔢 *Problem focuses on maintaining minimum number using stack logic.*

---

### ✅ `05_minimum_add_to_make_valid.cpp`  
Find the minimum number of parentheses needed to make a string expression valid.  
🔄 *Uses stack to validate parentheses and count needed additions.*

---

### 🔥 Queue-Based Problems

---

### ✅ `06_first_non_repeating_char.cpp`  
Given a stream of characters, print the **first non-repeating character** at each point.  
👂 *Uses queue and hash map for O(n) streaming solution.*

---

### ✅ `07_sliding_window_maximum.cpp`  
Find the **maximum in every window** of size K in an array using a deque.  
📊 *Optimized deque-based approach for sliding window maximum.*

---

### ✅ `08_rotten_oranges.cpp`  
BFS-style grid traversal to compute time needed to rot all oranges in a matrix.  
🟠 *Queue-driven multi-source BFS for shortest time calculation.*

---

### ✅ `09_interleaving_queue_halves.cpp`  
Interleave the **first half** of a queue with the **second half**.  
🔄 *Manipulates queue to merge halves in alternate order.*

---

### ✅ `10_maximum_of_all_subarrays_of_size_k.cpp`  
Find the **maximum element** in every subarray of size K using a deque.  
📈 *Sliding window maximum problem solved with efficient deque usage.*

---

## 🏁 Summary

| #   | Program                              | Data Structure | Techniques Used                |
|-----|------------------------------------|----------------|-------------------------------|
| 01  | Next Greater Element                | Stack          | Monotonic Stack                |
| 02  | Largest Rectangle in Histogram     | Stack          | Stack + Area Calculation       |
| 03  | Celebrity Problem                  | Stack          | Elimination using Stack        |
| 04  | Remove K Digits                   | Stack          | Greedy Stack                   |
| 05  | Minimum Add to Make Parentheses Valid | Stack          | Parentheses Matching           |
| 06  | First Non-Repeating Character      | Queue          | Queue + Hash Map               |
| 07  | Sliding Window Maximum             | Deque (Queue)  | Sliding Window + Deque         |
| 08  | Rotten Oranges                    | Queue          | BFS on Grid                   |
| 09  | Interleaving Queue Halves          | Queue          | Queue Manipulation             |
| 10  | Maximum of All Subarrays of Size K | Deque (Queue)  | Sliding Window + Deque         |

---

## 📎 Useful Links

- GitHub Repository: https://github.com/MuhammadFurqangithhub 
- Medium Articles: https://medium.com/@muhammadfurqan17
- LinkedIn Profile: https://www.linkedin.com/in/m-furqan/
---

> 🚀 *Keep coding, keep improving. These fundamental problems sharpen your understanding and prepare you for complex challenges!*
